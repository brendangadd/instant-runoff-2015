'use strict';

/**
 * A single vote (akin to a ballot) which holds a ranking of parties (which are just strings).
 *
 * Since votes are generated by ranking one party at a time, each vote has an open/closed state. The
 * closed state indicates that the vote can receive no more ranks. This allows a set of votes to be
 * generated over a number of iterations while allowing a vote to be completed part way through
 * (indicating that the voter does not wish to rank any more parties).
 */
class Vote {

   constructor() {
      this.ranking = [];
      this.isClosed = false;
   }

   hasRankFor(party) {
      return this.ranking.indexOf(party) >= 0;
   }

   addRankFor(party) {
      if (this.hasRankFor(party)) {
         throw new Error('Vote already has a rank for ' + party + '.');
      }
      if (this.isClosed) {
         throw new Error('Ranks cannot be added to a closed vote.');
      }
      this.ranking.push(party);
      return this;
   }

   close() {
      this.isClosed = true;
      return this;
   }

}

class InstantRunoffElection {

   constructor(votes) {
      this.votes = votes;
      this.assignment = {};
      this.exhaustedVotes = [];
      for (let vote of votes) {
         if (vote.ranking.length === 0) {
            this.exhaustedVotes.push(vote);
         } else {
            let assignee = vote.ranking[0];
            if (!this.assignment.hasOwnProperty(assignee)) {
               this.assignment[assignee] = [];
            }
            this.assignment[assignee].push(vote);
         }
      }
   }

   leader() {
      let maxAssignee = {numVotes: 0};

      for (let assignee of Object.keys(this.assignment)) {
         let numVotes = this.assignment[assignee].length;
         if (numVotes > maxAssignee.numVotes) {
            maxAssignee = {name: assignee, numVotes};
         }
      }

      return maxAssignee.name;
   }

   trailer () {
      let minAssignee = {numVotes: Number.MAX_SAFE_INTEGER};

      for (let assignee of Object.keys(this.assignment)) {
         let numVotes = this.assignment[assignee].length;
         if (numVotes < minAssignee.numVotes) {
            minAssignee = {name: assignee, numVotes};
         }
      }

      return minAssignee.name;
   }

   hasWinner() {
      return this.assignment[this.leader()].length > this.votes.length / 2
         || this.assignment.length <= 2
      ;
   }

   advanceRound() {
      if (this.hasWinner()) {
         return;
      }

      let trailer = this.trailer();
      let votes = this.assignment[trailer];
      delete this.assignment[trailer];

      for (let vote of votes) {
         let isReassigned = false;
         for (let rank of vote.ranking) {
            if (this.assignment.hasOwnProperty(rank)) {
               this.assignment[rank].push(vote);
               isReassigned = true;
               break;
            }
         }
         if (!isReassigned) {
            this.exhaustedVotes.push(vote);
         }
      }
   }

}

/**
 * Logs the distribution of the parties chosen at the specified
 * rank among the supplied array of votes.
 */
function logDistribution(votes, rank) {
   var distribution = {'BLANK': 0};
   for (let party of Object.keys(NEXT_RANK_DISTRIBUTION)) {
      distribution[party] = 0;
   }
   for (let vote of votes) {
      let party = vote.ranking[rank] || 'BLANK';
      distribution[party]++;
   }
   let total = Object.keys(distribution)
      .reduce((memo, key) => memo + distribution[key], 0)
   ;
   for (let key of Object.keys(distribution)) {
      distribution[key] /= total;
   }
   console.log(distribution);
}

/**
 * Generates `numVotes` votes with ranks distributed according
 * to the supplied `nextRankDistribution`.
 */
function generateVotes(numVotes, nextRankDistribution) {
   let votes = [];
   for (let i = 0; i < numVotes; i++) {
      votes.push(new Vote);
   }

   while (generateRanks(votes, nextRankDistribution));

   return votes;
}

/**
 * For each of the supplied votes, generates the next rank as per the
 * supplied `nextRankDistribution`. Closes the vote instead if a new
 * rank is not added.
 */
function generateRanks(votes, nextRankDistribution) {
   let didAddRank = false;

   for (let vote of votes) {
      if (vote.isClosed) {
         continue;
      }

      let numRanks = vote.ranking.length;
      let lastRank = numRanks > 0 ? vote.ranking[numRanks - 1] : 'BLANK';
      let distribution = nextRankDistribution[lastRank];

      let rnd = Math.random();
      let acc = 0;
      for (let item of distribution) {
         acc += item.probability;
         if (rnd < acc) {
            if (!vote.hasRankFor(item.party)) {
               vote.addRankFor(item.party);
               didAddRank = true;
            }
            break;
         }
      }

      if (vote.ranking.length === numRanks) {
         // No next rank was given. Close the vote.
         vote.close();
      }
   }

   return didAddRank;
}
